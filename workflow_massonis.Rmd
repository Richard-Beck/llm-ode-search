---
title: "workflow"
author: "RJB"
date: "2025-08-12"
output:
  pdf_document: default
  html_document: default
---


```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir="~/projects/llm-ode-search/")
```

```{r,include}
#' @description Loads all optimization results from a directory and plots the
#' error values as a tree to visualize the iterative search process.
#'
#' @param outDir The path to the main output directory containing the 'opt' subdirectory.
#'
plot_opt_tree <- function(outDir) {
  
  # 1. Find and load all optimization result files
  opt_path <- file.path(outDir, "opt")
  opt_files <- list.files(opt_path, pattern = "opt_\\d+\\.Rds", full.names = TRUE)
  
  # Extract iteration number from filename and sort files chronologically
  iter_nums <- as.numeric(gsub(".*_(\\d+)\\.Rds", "\\1", opt_files))
  opt_files <- opt_files[order(iter_nums)]
  
  if (length(opt_files) == 0) {
    message("No optimization files found in: ", opt_path)
    return(invisible(NULL))
  }
  
  # 2. Extract all error values into a single data frame
  all_errors <- do.call(rbind, lapply(seq_along(opt_files), function(i) {
    opt_list <- readRDS(opt_files[i])
    errors <- sapply(opt_list, function(o) o$opt$value)
    #errors[errors>(median(errors)+sd(errors))] <- (median(errors)*3)
    data.frame(
      iteration = i - 1, # Start iterations from 0
      candidate = 1:length(errors),
      error = errors
    )
  }))
  
  
  # 3. Find the best (minimum) error for each iteration
  best_errors <- aggregate(error ~ iteration, data = all_errors, FUN = min)
  
  # 4. Create the plot
  plot(all_errors$iteration, all_errors$error,
       xlab = "Iteration", ylab = "Objective Function Value (Error)",
       main = "Optimization Search Tree",
       pch = 1, col = "gray50",
       cex = 1.2, xaxt = "n")
  axis(1, at = unique(all_errors$iteration)) # Ensure integer ticks on x-axis

  # Draw lines connecting the best of one generation to the next
  if (nrow(best_errors) > 1) {
    for (i in 1:(nrow(best_errors) - 1)) {
      parent_node <- best_errors[i, ]
      child_nodes <- all_errors[all_errors$iteration == i, ]
      segments(parent_node$iteration, parent_node$error,
               child_nodes$iteration, child_nodes$error,
               col = "gray80", lty = 2)
    }
  }

  # Highlight the best model in each iteration
  points(best_errors$iteration, best_errors$error, pch = 19, col = "red", cex = 1.5)
  lines(best_errors$iteration, best_errors$error, col = "red", lwd = 2)
  
  legend("topright",
         legend = c("Candidate Model", "Best Model", "Progression"),
         pch = c(1, 19, NA),
         lty = c(NA, NA, 1),
         col = c("gray50", "red", "red"),
         bty = "n")
}
```


```{r}
target_data <- read.csv("data/ground_truth_raw/GT_Bacterial_train10pct.csv")
colnames(target_data)[1:2] <- c("condition", "replicate")
xdx <- get_deriv(target_data)

outDir <- "tests/bacterial_deriv_gpt-oss-120b_v3"
LLM_ID <- "gpt-oss-120b"

source("R/optim_utils.R")
source("R/llm-ode-search.R")

run_llm_ode_search(xdx, outDir, LLM_ID, max_iter = 5) 
plot_opt_tree(outDir)
```


```{r}

target_data <- read.csv("data/ground_truth_raw/GT_Microbial_train10pct.csv")
colnames(target_data)[1:2] <- c("condition", "replicate")
xdx <- get_deriv(target_data)

outDir <- "tests/microbial_deriv_gpt-oss-120b"
LLM_ID <- "gpt-oss-120b"

source("R/optim_utils.R")
source("R/llm-ode-search.R")

run_llm_ode_search(xdx, outDir, LLM_ID, max_iter = 10) 
plot_opt_tree(outDir)
```





